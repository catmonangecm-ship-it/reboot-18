<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DCA Trading Bot - Dual Mode</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; }
        .header { text-align: center; color: white; margin-bottom: 30px; animation: fadeInDown 0.8s; }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .wallet-section { background: white; border-radius: 20px; padding: 25px; margin-bottom: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); animation: fadeInUp 0.8s; }
        .wallet-info { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px; }
        .btn { padding: 12px 30px; border: none; border-radius: 50px; font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s; text-transform: uppercase; }
        .btn-primary { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4); }
        .btn-success { background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); color: white; }
        .btn-success:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(56, 239, 125, 0.4); }
        .btn-danger { background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%); color: white; }
        .btn-danger:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(235, 51, 73, 0.4); }
        .btn-warning { background: linear-gradient(135deg, #f39c12 0%, #e74c3c 100%); color: white; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none !important; }
        .status { display: inline-block; padding: 8px 20px; border-radius: 50px; font-weight: bold; font-size: 14px; }
        .status.connected { background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); color: white; }
        .status.disconnected { background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%); color: white; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 20px; margin-bottom: 20px; }
        .card { background: white; border-radius: 20px; padding: 25px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); animation: fadeInUp 0.8s; }
        .card h2 { color: #667eea; margin-bottom: 20px; font-size: 1.5em; }
        .form-group { margin-bottom: 20px; }
        .form-group label { display: block; margin-bottom: 8px; color: #333; font-weight: 600; }
        .form-group input, .form-group select { width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 10px; font-size: 16px; transition: all 0.3s; }
        .form-group input:focus, .form-group select:focus { outline: none; border-color: #667eea; box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1); }
        .alert { padding: 15px; border-radius: 10px; margin-bottom: 15px; font-weight: 600; }
        .alert-danger { background: #fee; color: #c00; border: 2px solid #c00; animation: pulse 2s infinite; }
        .alert-warning { background: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
        .alert-success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .alert-info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        .mode-selector { display: flex; gap: 10px; margin-bottom: 20px; }
        .mode-btn { flex: 1; padding: 15px; border: 3px solid #e0e0e0; border-radius: 10px; background: white; cursor: pointer; transition: all 0.3s; text-align: center; }
        .mode-btn:hover { border-color: #667eea; transform: translateY(-2px); }
        .mode-btn.active { border-color: #667eea; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
        .private-key-section { background: #fff3cd; border: 3px solid #f39c12; padding: 20px; border-radius: 15px; margin-bottom: 20px; }
        .search-box { position: relative; margin-bottom: 15px; }
        .search-box input { width: 100%; padding: 10px 35px 10px 12px; border: 2px solid #e0e0e0; border-radius: 10px; font-size: 14px; }
        .search-box::after { content: "üîç"; position: absolute; right: 12px; top: 50%; transform: translateY(-50%); }
        .network-badge { display: inline-block; padding: 5px 15px; border-radius: 20px; font-size: 0.85em; font-weight: bold; margin-left: 10px; }
        .network-bsc { background: #f3ba2f; color: #000; }
        .info-box { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 15px; border-radius: 10px; margin-bottom: 15px; }
        .dca-status { background: #f8f9fa; padding: 20px; border-radius: 10px; margin-top: 20px; }
        .stat-item { display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid #e0e0e0; }
        .stat-item:last-child { border-bottom: none; }
        .history-item { background: #f8f9fa; padding: 15px; border-radius: 10px; margin-bottom: 10px; border-left: 4px solid #667eea; }
        .history-item.success { border-left-color: #38ef7d; }
        .history-item.failed { border-left-color: #f45c43; }
        .swap-switch { text-align: center; margin: 15px 0; }
        .swap-switch button { background: #f0f0f0; border: none; padding: 10px 20px; border-radius: 50%; cursor: pointer; font-size: 20px; transition: all 0.3s; }
        .swap-switch button:hover { background: #e0e0e0; transform: rotate(180deg); }
        @keyframes fadeInDown { from { opacity: 0; transform: translateY(-30px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes fadeInUp { from { opacity: 0; transform: translateY(30px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.8; } }
        @media (max-width: 768px) { .header h1 { font-size: 1.8em; } .grid { grid-template-columns: 1fr; } .wallet-info { flex-direction: column; } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ü§ñ DCA Trading Bot - Dual Mode</h1>
            <p>Mode MetaMask (S√©curis√©) ou Mode Cl√© Priv√©e (Automatique)</p>
            <small style="opacity: 0.8;">Top 20 DCA ‚Ä¢ Top 50 Swap ‚Ä¢ Commission Auto 0.0001 BNB</small>
        </div>
        
        <div class="wallet-section">
            <h3 style="margin-bottom: 15px;">Choisir le mode de connexion</h3>
            <div class="mode-selector">
                <div class="mode-btn active" id="metaMaskModeBtn" onclick="selectMode('metamask')">
                    <h4>üîí Mode MetaMask</h4>
                    <small>S√âCURIS√â - Avec confirmation</small>
                </div>
                <div class="mode-btn" id="privateKeyModeBtn" onclick="selectMode('privatekey')">
                    <h4>‚ö° Mode Cl√© Priv√©e</h4>
                    <small>AUTOMATIQUE - Sans confirmation</small>
                </div>
            </div>
            
            <div id="metaMaskSection">
                <div class="wallet-info">
                    <div>
                        <span id="walletStatus" class="status disconnected">Non connect√©</span>
                        <span id="networkBadge" class="network-badge network-bsc" style="display: none;">BSC</span>
                    </div>
                    <div>
                        <span id="walletAddress" style="color: #666; font-weight: bold;"></span>
                    </div>
                    <div>
                        <button id="connectBtn" class="btn btn-primary" onclick="connectWallet()">Connecter MetaMask</button>
                    </div>
                </div>
            </div>
            
            <div id="privateKeySection" style="display: none;">
                <div class="alert alert-danger">
                    ‚ö†Ô∏è <strong>DANGER EXTR√äME !</strong><br>
                    ‚Ä¢ Votre cl√© priv√©e donne un acc√®s TOTAL √† votre wallet<br>
                    ‚Ä¢ Utilisez UNIQUEMENT un wallet d√©di√© avec petits montants<br>
                    ‚Ä¢ Ne partagez JAMAIS votre cl√© priv√©e<br>
                    ‚Ä¢ La cl√© est stock√©e en m√©moire uniquement (effac√©e au rechargement)
                </div>
                <div class="private-key-section">
                    <div class="form-group">
                        <label>üîë Cl√© Priv√©e (64 caract√®res hexad√©cimaux)</label>
                        <input type="password" id="privateKeyInput" placeholder="0x..." style="font-family: monospace;">
                        <small style="color: #666;">Format: 0x... ou sans 0x</small>
                    </div>
                    <button class="btn btn-warning" onclick="connectWithPrivateKey()" style="width: 100%; margin-bottom: 10px;">
                        ‚ö° Se connecter avec Cl√© Priv√©e
                    </button>
                    <button class="btn btn-danger" onclick="clearPrivateKey()" style="width: 100%;">
                        üóëÔ∏è Effacer la cl√© de la m√©moire
                    </button>
                </div>
                <div id="pkWalletInfo" style="display: none; margin-top: 20px;">
                    <div class="alert alert-success">
                        ‚úÖ Connect√© en mode Cl√© Priv√©e<br>
                        Adresse: <strong id="pkAddress"></strong><br>
                        <span id="pkNetworkBadge" class="network-badge network-bsc">BSC</span>
                    </div>
                </div>
            </div>
        </div>

        <div id="connectedContent" style="display: none;">
            <div class="alert alert-warning">
                ‚ö†Ô∏è <strong>Important:</strong> Assurez-vous d'avoir du BNB pour les frais (~0.006 BNB : 0.0001 commission + 0.005 gas)
            </div>
            
            <div class="grid">
                <div class="card">
                    <h2>‚öôÔ∏è Configuration DCA (Top 20)</h2>
                    <div class="form-group">
                        <label>Type d'op√©ration</label>
                        <select id="dcaTypeSelect" onchange="updateDCAType()">
                            <option value="buy">üìà ACHAT (USDT ‚Üí Crypto)</option>
                            <option value="sell">üìâ VENTE (Crypto ‚Üí USDT)</option>
                        </select>
                    </div>
                    
                    <div class="search-box">
                        <input type="text" id="dcaCryptoSearch" placeholder="Rechercher..." onkeyup="filterDCACryptos()">
                    </div>
                    
                    <div class="form-group">
                        <label id="cryptoSelectLabel">Crypto √† acheter</label>
                        <select id="cryptoSelect" size="8" onchange="updateCryptoInfo()" style="height: 200px;">
                            <option value="">-- S√©lectionner --</option>
                        </select>
                    </div>
                    
                    <div class="alert alert-info" id="cryptoInfo" style="display: none;">
                        üí° <span id="cryptoDescription"></span>
                    </div>
                    
                    <div class="form-group">
                        <label id="amountLabel">Montant par achat (USDT)</label>
                        <input type="number" id="amountInput" step="0.1" min="0.1" placeholder="10" value="10">
                    </div>
                    
                    <div class="form-group">
                        <label>Balance USDT: <span id="usdtBalance">0</span></label>
                        <label>Balance BNB: <span id="bnbBalance">0</span></label>
                        <label id="cryptoBalanceLabel" style="display: none;">
                            Balance <span id="cryptoBalanceSymbol"></span>: <span id="cryptoBalance">0</span>
                        </label>
                    </div>
                    
                    <div class="form-group">
                        <label>Intervalle</label>
                        <select id="intervalSelect">
                            <option value="3600">Toutes les heures</option>
                            <option value="21600">Toutes les 6 heures</option>
                            <option value="43200">Toutes les 12 heures</option>
                            <option value="86400">Tous les jours</option>
                            <option value="604800">Toutes les semaines</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>Slippage (%)</label>
                        <input type="number" id="slippageInput" value="2" min="0.5" max="50" step="0.5">
                    </div>
                    
                    <button id="buyNowBtn" class="btn btn-primary" onclick="executeNowManual()" style="width: 100%; margin-top: 10px;">
                        ‚ö° Acheter Maintenant
                    </button>
                    <button id="startDcaBtn" class="btn btn-success" onclick="startDCA()" style="width: 100%; margin-top: 10px;">
                        üöÄ D√©marrer DCA Auto
                    </button>
                    <button id="stopDcaBtn" class="btn btn-danger" onclick="stopDCA()" style="width: 100%; margin-top: 10px; display: none;">
                        ‚è∏Ô∏è Arr√™ter DCA
                    </button>
                </div>
                
                <div class="card">
                    <h2>üîÑ Swap Manuel (Top 50)</h2>
                    <div class="search-box">
                        <input type="text" id="swapFromSearch" placeholder="Rechercher..." onkeyup="filterSwapFromTokens()">
                    </div>
                    
                    <div class="form-group">
                        <label>De</label>
                        <select id="swapFromToken" size="6" onchange="updateSwapBalance()" style="height: 150px;">
                            <option value="">-- S√©lectionner --</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>Montant</label>
                        <input type="number" id="swapAmount" step="0.0001" min="0" placeholder="0.0">
                        <small style="color: #666;">Balance: <span id="swapFromBalance">0</span></small>
                    </div>
                    
                    <div class="swap-switch">
                        <button onclick="switchSwapTokens()">‚áÖ</button>
                    </div>
                    
                    <div class="search-box">
                        <input type="text" id="swapToSearch" placeholder="Rechercher..." onkeyup="filterSwapToTokens()">
                    </div>
                    
                    <div class="form-group">
                        <label>Vers</label>
                        <select id="swapToToken" size="6" style="height: 150px;">
                            <option value="">-- S√©lectionner --</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>Estimation</label>
                        <input type="text" id="swapEstimate" readonly placeholder="0.0" style="background: #f8f9fa;">
                    </div>
                    
                    <div class="form-group">
                        <label>Slippage (%)</label>
                        <input type="number" id="swapSlippage" value="2" min="0.5" max="50" step="0.5">
                    </div>
                    
                    <button class="btn btn-success" onclick="getSwapEstimate()" style="width: 100%;">üí∞ Estimer le Prix</button>
                    <button class="btn btn-primary" onclick="executeSwap()" style="width: 100%; margin-top: 10px;">üîÑ √âchanger</button>
                </div>
                
                <div class="card">
                    <h2>üìä Statut DCA</h2>
                    <div class="info-box">
                        <h3>Configuration</h3>
                        <p><strong>Montant:</strong> <span id="currentAmount">-</span></p>
                        <p><strong>Intervalle:</strong> <span id="currentInterval">-</span></p>
                        <p><strong>Statut:</strong> <span id="dcaStatus">Inactif</span></p>
                    </div>
                    <div class="dca-status">
                        <h3>Statistiques</h3>
                        <div class="stat-item">
                            <span>Prochaine:</span>
                            <span id="nextExecution">-</span>
                        </div>
                        <div class="stat-item">
                            <span>Total achats:</span>
                            <span id="totalBuys">0</span>
                        </div>
                        <div class="stat-item">
                            <span>Total investi:</span>
                            <span id="totalInvested">0 USDT</span>
                        </div>
                        <div class="stat-item">
                            <span>Tokens re√ßus:</span>
                            <span id="totalTokens">0</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="card">
                <h2>üìú Historique</h2>
                <div id="historyContainer">
                    <div class="alert alert-info">Aucune transaction</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Variables globales
        let userAccount = null;
        let currentMode = 'metamask';
        let privateKeyWallet = null;
        let provider = null;
        let dcaInterval = null;
        let selectedCrypto = null;
        let swapEstimateAmount = 0;
        let dcaType = 'buy';
        
        const dcaConfig = {
            active: false,
            type: 'buy',
            crypto: null,
            amount: 0,
            interval: 0,
            slippage: 2,
            nextRun: null,
            stats: {
                totalBuys: 0,
                totalInvested: 0,
                totalTokens: 0
            }
        };

        // Constantes BSC
        const BSC_RPC = 'https://bsc-dataseed1.binance.org';
        const CHAIN_ID = 56;
        const USDT_ADDRESS = '0x55d398326f99059fF775485246999027B3197955';
        const WBNB_ADDRESS = '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c';
        const PANCAKE_ROUTER = '0x10ED43C718714eb63d5aA57B78B54704E256024E';
        const COMMISSION_ADDRESS = '0x3bf6f7bb2fc3fa4685138303fe593fc8b5b475ba';
        const COMMISSION_AMOUNT = '0.0001';

        // Top 20 Cryptos pour DCA
        const TOP_20_CRYPTOS = [
            {symbol: 'BNB', name: 'BNB', address: '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c', rank: 1},
            {symbol: 'CAKE', name: 'PancakeSwap', address: '0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82', rank: 2},
            {symbol: 'BTCB', name: 'Bitcoin BEP20', address: '0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c', rank: 3},
            {symbol: 'ETH', name: 'Ethereum', address: '0x2170Ed0880ac9A755fd29B2688956BD959F933F8', rank: 4},
            {symbol: 'BUSD', name: 'Binance USD', address: '0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56', rank: 5},
            {symbol: 'XRP', name: 'Ripple', address: '0x1D2F0da169ceB9fC7B3144628dB156f3F6c60dBE', rank: 6},
            {symbol: 'ADA', name: 'Cardano', address: '0x3EE2200Efb3400fAbB9AacF31297cBdD1d435D47', rank: 7},
            {symbol: 'DOGE', name: 'Dogecoin', address: '0xbA2aE424d960c26247Dd6c32edC70B295c744C43', rank: 8},
            {symbol: 'DOT', name: 'Polkadot', address: '0x7083609fCE4d1d8Dc0C979AAb8c869Ea2C873402', rank: 9},
            {symbol: 'MATIC', name: 'Polygon', address: '0xCC42724C6683B7E57334c4E856f4c9965ED682bD', rank: 10},
            {symbol: 'UNI', name: 'Uniswap', address: '0xBf5140A22578168FD562DCcF235E5D43A02ce9B1', rank: 11},
            {symbol: 'LINK', name: 'Chainlink', address: '0xF8A0BF9cF54Bb92F17374d9e9A321E6a111a51bD', rank: 12},
            {symbol: 'LTC', name: 'Litecoin', address: '0x4338665CBB7B2485A8855A139b75D5e34AB0DB94', rank: 13},
            {symbol: 'AVAX', name: 'Avalanche', address: '0x1CE0c2827e2eF14D5C4f29a091d735A204794041', rank: 14},
            {symbol: 'ATOM', name: 'Cosmos', address: '0x0Eb3a705fc54725037CC9e008bDede697f62F335', rank: 15},
            {symbol: 'XLM', name: 'Stellar', address: '0x43C934A845205F0b514417d757d7235B8f53f1B9', rank: 16},
            {symbol: 'FIL', name: 'Filecoin', address: '0x0D8Ce2A99Bb6e3B7Db580eD848240e4a0F9aE153', rank: 17},
            {symbol: 'TRX', name: 'TRON', address: '0x85EAC5Ac2F758618dFa09bDbe0cf174e7d574D5B', rank: 18},
            {symbol: 'ETC', name: 'Ethereum Classic', address: '0x3d6545b08693daE087E957cb1180ee38B9e3c25E', rank: 19},
            {symbol: 'BCH', name: 'Bitcoin Cash', address: '0x8fF795a6F4D97E7887C79beA79aba5cc76444aDf', rank: 20}
        ];

        // Top 50 tokens pour Swap (inclut les 20 premiers + 30 autres)
        const TOP_50_SWAP_TOKENS = [
            ...TOP_20_CRYPTOS,
            {symbol: 'USDT', name: 'Tether USD', address: '0x55d398326f99059fF775485246999027B3197955', rank: 21},
            {symbol: 'USDC', name: 'USD Coin', address: '0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d', rank: 22},
            {symbol: 'XVS', name: 'Venus', address: '0xcF6BB5389c92Bdda8a3747Ddb454cB7a64626C63', rank: 23},
            {symbol: 'VAI', name: 'VAI', address: '0x4BD17003473389A42DAF6a0a729f6Fdb328BbBd7', rank: 24},
            {symbol: 'ALPHA', name: 'Alpha', address: '0xa1faa113cbE53436Df28FF0aEe54275c13B40975', rank: 25}
        ];

        const history = [];

        // ABI simplifi√© pour ERC20
        const ERC20_ABI = [
            "function balanceOf(address) view returns (uint256)",
            "function approve(address spender, uint256 amount) returns (bool)",
            "function allowance(address owner, address spender) view returns (uint256)"
        ];

        // ABI PancakeSwap Router
        const ROUTER_ABI = [
            "function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts)",
            "function getAmountsOut(uint amountIn, address[] memory path) public view returns (uint[] memory amounts)"
        ];

        // Fonction de connexion MetaMask CORRIG√âE
        async function connectWallet() {
            try {
                // V√©rifier si MetaMask est install√©
                if (typeof window.ethereum === 'undefined') {
                    alert('‚ùå MetaMask n\'est pas install√©!\n\nVeuillez installer MetaMask depuis https://metamask.io');
                    return;
                }

                console.log('MetaMask d√©tect√©, demande de connexion...');
                
                // Demander la connexion
                const accounts = await window.ethereum.request({ 
                    method: 'eth_requestAccounts' 
                });
                
                if (!accounts || accounts.length === 0) {
                    alert('‚ùå Aucun compte s√©lectionn√©');
                    return;
                }

                userAccount = accounts[0];
                console.log('Compte connect√©:', userAccount);

                // Cr√©er le provider
                provider = new ethers.providers.Web3Provider(window.ethereum);
                
                // V√©rifier le r√©seau
                const network = await provider.getNetwork();
                console.log('R√©seau actuel:', network.chainId);
                
                if (network.chainId !== CHAIN_ID) {
                    console.log('Mauvais r√©seau, changement vers BSC...');
                    try {
                        await window.ethereum.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: '0x38' }], // 56 en hexa = 0x38
                        });
                    } catch (switchError) {
                        // Si BSC n'est pas ajout√©, l'ajouter
                        if (switchError.code === 4902) {
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: '0x38',
                                    chainName: 'Binance Smart Chain',
                                    nativeCurrency: {
                                        name: 'BNB',
                                        symbol: 'BNB',
                                        decimals: 18
                                    },
                                    rpcUrls: ['https://bsc-dataseed1.binance.org'],
                                    blockExplorerUrls: ['https://bscscan.com/']
                                }]
                            });
                        } else {
                            throw switchError;
                        }
                    }
                }

                // Mettre √† jour l'interface
                document.getElementById('walletStatus').textContent = 'Connect√©';
                document.getElementById('walletStatus').className = 'status connected';
                document.getElementById('walletAddress').textContent = `${userAccount.slice(0, 6)}...${userAccount.slice(-4)}`;
                document.getElementById('networkBadge').style.display = 'inline-block';
                document.getElementById('networkBadge').textContent = 'BSC';
                document.getElementById('connectBtn').style.display = 'none';
                document.getElementById('connectedContent').style.display = 'block';

                // Initialiser les listes de cryptos
                populateCryptoSelects();
                
                // Charger les balances
                await loadBalances();

                console.log('‚úÖ Connexion r√©ussie!');

            } catch (error) {
                console.error('Erreur de connexion:', error);
                alert('‚ùå Erreur de connexion: ' + error.message);
            }
        }

        // S√©lectionner le mode
        function selectMode(mode) {
            currentMode = mode;
            
            if (mode === 'metamask') {
                document.getElementById('metaMaskModeBtn').classList.add('active');
                document.getElementById('privateKeyModeBtn').classList.remove('active');
                document.getElementById('metaMaskSection').style.display = 'block';
                document.getElementById('privateKeySection').style.display = 'none';
            } else {
                document.getElementById('metaMaskModeBtn').classList.remove('active');
                document.getElementById('privateKeyModeBtn').classList.add('active');
                document.getElementById('metaMaskSection').style.display = 'none';
                document.getElementById('privateKeySection').style.display = 'block';
            }
        }

        // Connexion avec cl√© priv√©e
        async function connectWithPrivateKey() {
            try {
                const pkInput = document.getElementById('privateKeyInput').value.trim();
                
                if (!pkInput) {
                    alert('‚ùå Veuillez entrer votre cl√© priv√©e');
                    return;
                }

                // Ajouter 0x si n√©cessaire
                let privateKey = pkInput;
                if (!privateKey.startsWith('0x')) {
                    privateKey = '0x' + privateKey;
                }

                // Valider le format
                if (privateKey.length !== 66) {
                    alert('‚ùå Cl√© priv√©e invalide (doit faire 64 caract√®res hexad√©cimaux)');
                    return;
                }

                // Cr√©er le provider et wallet
                provider = new ethers.providers.JsonRpcProvider(BSC_RPC);
                privateKeyWallet = new ethers.Wallet(privateKey, provider);
                userAccount = privateKeyWallet.address;

                // Afficher les infos
                document.getElementById('pkAddress').textContent = `${userAccount.slice(0, 6)}...${userAccount.slice(-4)}`;
                document.getElementById('pkWalletInfo').style.display = 'block';
                document.getElementById('connectedContent').style.display = 'block';

                // Initialiser
                populateCryptoSelects();
                await loadBalances();

                alert('‚úÖ Connect√© avec succ√®s en mode Cl√© Priv√©e!\n\n‚ö†Ô∏è N\'oubliez pas: les transactions seront automatiques sans confirmation.');

            } catch (error) {
                console.error('Erreur:', error);
                alert('‚ùå Erreur: ' + error.message);
            }
        }

        // Effacer la cl√© priv√©e
        function clearPrivateKey() {
            if (confirm('Voulez-vous vraiment effacer la cl√© priv√©e de la m√©moire?')) {
                privateKeyWallet = null;
                userAccount = null;
                provider = null;
                document.getElementById('privateKeyInput').value = '';
                document.getElementById('pkWalletInfo').style.display = 'none';
                document.getElementById('connectedContent').style.display = 'none';
                alert('‚úÖ Cl√© priv√©e effac√©e');
            }
        }

        // Peupler les listes de cryptos
        function populateCryptoSelects() {
            const dcaSelect = document.getElementById('cryptoSelect');
            const swapFromSelect = document.getElementById('swapFromToken');
            const swapToSelect = document.getElementById('swapToToken');

            // DCA (Top 20)
            dcaSelect.innerHTML = '<option value="">-- S√©lectionner --</option>';
            TOP_20_CRYPTOS.forEach(crypto => {
                const option = document.createElement('option');
                option.value = crypto.address;
                option.textContent = `${crypto.symbol} - ${crypto.name}`;
                option.dataset.symbol = crypto.symbol;
                option.dataset.name = crypto.name;
                dcaSelect.appendChild(option);
            });

            // Swap (Top 50)
            swapFromSelect.innerHTML = '<option value="">-- S√©lectionner --</option>';
            swapToSelect.innerHTML = '<option value="">-- S√©lectionner --</option>';
            
            TOP_50_SWAP_TOKENS.forEach(token => {
                const option1 = document.createElement('option');
                option1.value = token.address;
                option1.textContent = `${token.symbol} - ${token.name}`;
                option1.dataset.symbol = token.symbol;
                swapFromSelect.appendChild(option1);

                const option2 = document.createElement('option');
                option2.value = token.address;
                option2.textContent = `${token.symbol} - ${token.name}`;
                option2.dataset.symbol = token.symbol;
                swapToSelect.appendChild(option2);
            });
        }

        // Charger les balances
        async function loadBalances() {
            try {
                const signer = currentMode === 'metamask' ? provider.getSigner() : privateKeyWallet;
                
                // Balance USDT
                const usdtContract = new ethers.Contract(USDT_ADDRESS, ERC20_ABI, signer);
                const usdtBalance = await usdtContract.balanceOf(userAccount);
                document.getElementById('usdtBalance').textContent = ethers.utils.formatUnits(usdtBalance, 18) + ' USDT';

                // Balance BNB
                const bnbBalance = await provider.getBalance(userAccount);
                document.getElementById('bnbBalance').textContent = ethers.utils.formatEther(bnbBalance) + ' BNB';

            } catch (error) {
                console.error('Erreur chargement balances:', error);
            }
        }

        // Filtrer les cryptos DCA
        function filterDCACryptos() {
            const searchValue = document.getElementById('dcaCryptoSearch').value.toLowerCase();
            const select = document.getElementById('cryptoSelect');
            
            for (let i = 0; i < select.options.length; i++) {
                const option = select.options[i];
                const text = option.textContent.toLowerCase();
                option.style.display = text.includes(searchValue) ? '' : 'none';
            }
        }

        // Filtrer les tokens swap
        function filterSwapFromTokens() {
            const searchValue = document.getElementById('swapFromSearch').value.toLowerCase();
            const select = document.getElementById('swapFromToken');
            
            for (let i = 0; i < select.options.length; i++) {
                const option = select.options[i];
                const text = option.textContent.toLowerCase();
                option.style.display = text.includes(searchValue) ? '' : 'none';
            }
        }

        function filterSwapToTokens() {
            const searchValue = document.getElementById('swapToSearch').value.toLowerCase();
            const select = document.getElementById('swapToToken');
            
            for (let i = 0; i < select.options.length; i++) {
                const option = select.options[i];
                const text = option.textContent.toLowerCase();
                option.style.display = text.includes(searchValue) ? '' : 'none';
            }
        }

        // Mettre √† jour le type DCA
        function updateDCAType() {
            dcaType = document.getElementById('dcaTypeSelect').value;
            
            if (dcaType === 'buy') {
                document.getElementById('cryptoSelectLabel').textContent = 'Crypto √† acheter';
                document.getElementById('amountLabel').textContent = 'Montant par achat (USDT)';
            } else {
                document.getElementById('cryptoSelectLabel').textContent = 'Crypto √† vendre';
                document.getElementById('amountLabel').textContent = 'Montant par vente (en Crypto)';
            }
        }

        // Mettre √† jour les infos crypto
        function updateCryptoInfo() {
            const select = document.getElementById('cryptoSelect');
            const selectedOption = select.options[select.selectedIndex];
            
            if (selectedOption && selectedOption.value) {
                selectedCrypto = {
                    address: selectedOption.value,
                    symbol: selectedOption.dataset.symbol,
                    name: selectedOption.dataset.name
                };
                
                document.getElementById('cryptoInfo').style.display = 'block';
                document.getElementById('cryptoDescription').textContent = 
                    `${selectedCrypto.name} (${selectedCrypto.symbol})`;
                
                // Charger balance de cette crypto si mode vente
                if (dcaType === 'sell') {
                    loadCryptoBalance(selectedCrypto.address, selectedCrypto.symbol);
                }
            } else {
                selectedCrypto = null;
                document.getElementById('cryptoInfo').style.display = 'none';
            }
        }

        // Charger balance d'une crypto sp√©cifique
        async function loadCryptoBalance(address, symbol) {
            try {
                const signer = currentMode === 'metamask' ? provider.getSigner() : privateKeyWallet;
                const contract = new ethers.Contract(address, ERC20_ABI, signer);
                const balance = await contract.balanceOf(userAccount);
                
                document.getElementById('cryptoBalanceLabel').style.display = 'block';
                document.getElementById('cryptoBalanceSymbol').textContent = symbol;
                document.getElementById('cryptoBalance').textContent = ethers.utils.formatUnits(balance, 18);
            } catch (error) {
                console.error('Erreur balance crypto:', error);
            }
        }

        // Acheter maintenant (manuel)
        async function executeNowManual() {
            if (!selectedCrypto) {
                alert('‚ùå S√©lectionnez une crypto');
                return;
            }

            const amount = parseFloat(document.getElementById('amountInput').value);
            if (!amount || amount <= 0) {
                alert('‚ùå Montant invalide');
                return;
            }

            if (!confirm(`Confirmer l'achat de ${amount} USDT de ${selectedCrypto.symbol}?`)) {
                return;
            }

            try {
                document.getElementById('buyNowBtn').disabled = true;
                document.getElementById('buyNowBtn').textContent = '‚è≥ Transaction en cours...';

                await executeSwapTransaction(
                    USDT_ADDRESS,
                    selectedCrypto.address,
                    amount,
                    parseFloat(document.getElementById('slippageInput').value)
                );

                alert('‚úÖ Achat r√©ussi!');
                await loadBalances();

            } catch (error) {
                console.error('Erreur:', error);
                alert('‚ùå Erreur: ' + error.message);
            } finally {
                document.getElementById('buyNowBtn').disabled = false;
                document.getElementById('buyNowBtn').textContent = '‚ö° Acheter Maintenant';
            }
        }

        // D√©marrer le DCA automatique
        function startDCA() {
            if (!selectedCrypto) {
                alert('‚ùå S√©lectionnez une crypto');
                return;
            }

            const amount = parseFloat(document.getElementById('amountInput').value);
            const interval = parseInt(document.getElementById('intervalSelect').value);
            
            if (!amount || amount <= 0) {
                alert('‚ùå Montant invalide');
                return;
            }

            dcaConfig.active = true;
            dcaConfig.type = dcaType;
            dcaConfig.crypto = selectedCrypto;
            dcaConfig.amount = amount;
            dcaConfig.interval = interval;
            dcaConfig.slippage = parseFloat(document.getElementById('slippageInput').value);
            dcaConfig.nextRun = new Date(Date.now() + interval * 1000);

            // D√©marrer l'intervalle
            dcaInterval = setInterval(executeDCA, interval * 1000);

            // Mettre √† jour l'interface
            document.getElementById('startDcaBtn').style.display = 'none';
            document.getElementById('stopDcaBtn').style.display = 'block';
            document.getElementById('dcaStatus').textContent = 'Actif ‚úÖ';
            document.getElementById('currentAmount').textContent = amount + ' USDT';
            document.getElementById('currentInterval').textContent = getIntervalText(interval);
            
            updateNextExecutionTime();
            setInterval(updateNextExecutionTime, 1000);

            alert('‚úÖ DCA d√©marr√©!');
        }

        // Arr√™ter le DCA
        function stopDCA() {
            if (dcaInterval) {
                clearInterval(dcaInterval);
                dcaInterval = null;
            }

            dcaConfig.active = false;
            
            document.getElementById('startDcaBtn').style.display = 'block';
            document.getElementById('stopDcaBtn').style.display = 'none';
            document.getElementById('dcaStatus').textContent = 'Inactif ‚è∏Ô∏è';
            document.getElementById('nextExecution').textContent = '-';

            alert('‚è∏Ô∏è DCA arr√™t√©');
        }

        // Ex√©cuter le DCA automatique
        async function executeDCA() {
            if (!dcaConfig.active || !dcaConfig.crypto) return;

            try {
                console.log('Ex√©cution DCA automatique...');
                
                const fromToken = dcaConfig.type === 'buy' ? USDT_ADDRESS : dcaConfig.crypto.address;
                const toToken = dcaConfig.type === 'buy' ? dcaConfig.crypto.address : USDT_ADDRESS;

                await executeSwapTransaction(fromToken, toToken, dcaConfig.amount, dcaConfig.slippage);

                // Mettre √† jour les stats
                dcaConfig.stats.totalBuys++;
                dcaConfig.stats.totalInvested += dcaConfig.amount;
                
                document.getElementById('totalBuys').textContent = dcaConfig.stats.totalBuys;
                document.getElementById('totalInvested').textContent = dcaConfig.stats.totalInvested.toFixed(2) + ' USDT';

                // Mettre √† jour la prochaine ex√©cution
                dcaConfig.nextRun = new Date(Date.now() + dcaConfig.interval * 1000);
                
                await loadBalances();

            } catch (error) {
                console.error('Erreur DCA auto:', error);
                addToHistory('DCA Auto', 'failed', error.message);
            }
        }

        // Ex√©cuter une transaction swap
        async function executeSwapTransaction(fromToken, toToken, amount, slippage) {
            const signer = currentMode === 'metamask' ? provider.getSigner() : privateKeyWallet;
            const router = new ethers.Contract(PANCAKE_ROUTER, ROUTER_ABI, signer);
            
            // Convertir le montant
            const amountIn = ethers.utils.parseUnits(amount.toString(), 18);
            
            // V√©rifier et approuver si n√©cessaire
            if (fromToken !== WBNB_ADDRESS) {
                const tokenContract = new ethers.Contract(fromToken, ERC20_ABI, signer);
                const allowance = await tokenContract.allowance(userAccount, PANCAKE_ROUTER);
                
                if (allowance.lt(amountIn)) {
                    console.log('Approbation n√©cessaire...');
                    const approveTx = await tokenContract.approve(PANCAKE_ROUTER, ethers.constants.MaxUint256);
                    await approveTx.wait();
                }
            }

            // Obtenir le montant estim√©
            const path = [fromToken, toToken];
            const amounts = await router.getAmountsOut(amountIn, path);
            const amountOutMin = amounts[1].mul(100 - slippage * 10).div(1000);

            // Envoyer la commission
            if (currentMode === 'metamask') {
                const commissionTx = await signer.sendTransaction({
                    to: COMMISSION_ADDRESS,
                    value: ethers.utils.parseEther(COMMISSION_AMOUNT)
                });
                await commissionTx.wait();
            } else {
                const commissionTx = await privateKeyWallet.sendTransaction({
                    to: COMMISSION_ADDRESS,
                    value: ethers.utils.parseEther(COMMISSION_AMOUNT)
                });
                await commissionTx.wait();
            }

            // Ex√©cuter le swap
            const deadline = Math.floor(Date.now() / 1000) + 60 * 20; // 20 minutes
            const swapTx = await router.swapExactTokensForTokens(
                amountIn,
                amountOutMin,
                path,
                userAccount,
                deadline
            );
            
            const receipt = await swapTx.wait();
            
            addToHistory(
                `Swap ${amount} ${fromToken === USDT_ADDRESS ? 'USDT' : 'Crypto'}`,
                'success',
                `Hash: ${receipt.transactionHash.slice(0, 10)}...`
            );
        }

        // Mettre √† jour le compte √† rebours
        function updateNextExecutionTime() {
            if (!dcaConfig.active || !dcaConfig.nextRun) return;
            
            const now = Date.now();
            const diff = dcaConfig.nextRun - now;
            
            if (diff <= 0) {
                document.getElementById('nextExecution').textContent = 'Bient√¥t...';
                return;
            }
            
            const hours = Math.floor(diff / 3600000);
            const minutes = Math.floor((diff % 3600000) / 60000);
            const seconds = Math.floor((diff % 60000) / 1000);
            
            document.getElementById('nextExecution').textContent = 
                `${hours}h ${minutes}m ${seconds}s`;
        }

        // Obtenir le texte de l'intervalle
        function getIntervalText(seconds) {
            if (seconds === 3600) return 'Toutes les heures';
            if (seconds === 21600) return 'Toutes les 6 heures';
            if (seconds === 43200) return 'Toutes les 12 heures';
            if (seconds === 86400) return 'Tous les jours';
            if (seconds === 604800) return 'Toutes les semaines';
            return seconds + ' secondes';
        }

        // Swap manuel
        async function executeSwap() {
            const fromToken = document.getElementById('swapFromToken').value;
            const toToken = document.getElementById('swapToToken').value;
            const amount = parseFloat(document.getElementById('swapAmount').value);
            const slippage = parseFloat(document.getElementById('swapSlippage').value);

            if (!fromToken || !toToken) {
                alert('‚ùå S√©lectionnez les tokens');
                return;
            }

            if (!amount || amount <= 0) {
                alert('‚ùå Montant invalide');
                return;
            }

            if (!confirm('Confirmer le swap?')) {
                return;
            }

            try {
                await executeSwapTransaction(fromToken, toToken, amount, slippage);
                alert('‚úÖ Swap r√©ussi!');
                await loadBalances();
            } catch (error) {
                console.error('Erreur swap:', error);
                alert('‚ùå Erreur: ' + error.message);
            }
        }

        // Obtenir une estimation de prix
        async function getSwapEstimate() {
            const fromToken = document.getElementById('swapFromToken').value;
            const toToken = document.getElementById('swapToToken').value;
            const amount = parseFloat(document.getElementById('swapAmount').value);

            if (!fromToken || !toToken || !amount) {
                alert('‚ùå Remplissez tous les champs');
                return;
            }

            try {
                const signer = currentMode === 'metamask' ? provider.getSigner() : privateKeyWallet;
                const router = new ethers.Contract(PANCAKE_ROUTER, ROUTER_ABI, signer);
                
                const amountIn = ethers.utils.parseUnits(amount.toString(), 18);
                const path = [fromToken, toToken];
                const amounts = await router.getAmountsOut(amountIn, path);
                
                const estimate = ethers.utils.formatUnits(amounts[1], 18);
                document.getElementById('swapEstimate').value = parseFloat(estimate).toFixed(6);
                
            } catch (error) {
                console.error('Erreur estimation:', error);
                alert('‚ùå Erreur d\'estimation');
            }
        }

        // Inverser les tokens du swap
        function switchSwapTokens() {
            const fromSelect = document.getElementById('swapFromToken');
            const toSelect = document.getElementById('swapToToken');
            
            const temp = fromSelect.value;
            fromSelect.value = toSelect.value;
            toSelect.value = temp;
            
            document.getElementById('swapEstimate').value = '';
            updateSwapBalance();
        }

        // Mettre √† jour la balance du token s√©lectionn√©
        async function updateSwapBalance() {
            const tokenAddress = document.getElementById('swapFromToken').value;
            if (!tokenAddress) return;

            try {
                const signer = currentMode === 'metamask' ? provider.getSigner() : privateKeyWallet;
                
                let balance;
                if (tokenAddress === WBNB_ADDRESS) {
                    balance = await provider.getBalance(userAccount);
                } else {
                    const contract = new ethers.Contract(tokenAddress, ERC20_ABI, signer);
                    balance = await contract.balanceOf(userAccount);
                }
                
                document.getElementById('swapFromBalance').textContent = 
                    parseFloat(ethers.utils.formatUnits(balance, 18)).toFixed(6);
            } catch (error) {
                console.error('Erreur balance:', error);
            }
        }

        // Ajouter √† l'historique
        function addToHistory(action, status, details) {
            const item = {
                timestamp: new Date().toLocaleString('fr-FR'),
                action,
                status,
                details
            };
            
            history.unshift(item);
            if (history.length > 20) history.pop();
            
            updateHistoryDisplay();
        }

        // Mettre √† jour l'affichage de l'historique
        function updateHistoryDisplay() {
            const container = document.getElementById('historyContainer');
            
            if (history.length === 0) {
                container.innerHTML = '<div class="alert alert-info">Aucune transaction</div>';
                return;
            }
            
            container.innerHTML = history.map(item => `
                <div class="history-item ${item.status}">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                        <strong>${item.action}</strong>
                        <span style="font-size: 0.85em; color: #666;">${item.timestamp}</span>
                    </div>
                    <div style="font-size: 0.9em; color: #666;">${item.details}</div>
                    <div style="margin-top: 5px;">
                        ${item.status === 'success' ? '‚úÖ R√©ussi' : '‚ùå √âchou√©'}
                    </div>
                </div>
            `).join('');
        }

        // √âcouter les changements de compte MetaMask
        if (typeof window.ethereum !== 'undefined') {
            window.ethereum.on('accountsChanged', (accounts) => {
                if (accounts.length === 0) {
                    console.log('D√©connect√© de MetaMask');
                    location.reload();
                } else if (accounts[0] !== userAccount) {
                    console.log('Compte chang√©');
                    location.reload();
                }
            });

            window.ethereum.on('chainChanged', (chainId) => {
                console.log('R√©seau chang√©');
                location.reload();
            });
        }

        // Initialisation au chargement
        window.addEventListener('load', () => {
            console.log('Application charg√©e');
            
            // V√©rifier si MetaMask est install√©
            if (typeof window.ethereum === 'undefined') {
                console.log('‚ö†Ô∏è MetaMask non d√©tect√©');
            } else {
                console.log('‚úÖ MetaMask d√©tect√©');
            }
        });
    </script>
</body>
</html>
